"""
E. Королевская сортировка

ограничение по времени на тест: 1 секунда
ограничение по памяти на тест: 256 мегабайт
ввод: стандартный ввод
вывод: стандартный вывод

У нерушимого города-государства Иннолэнд богатая история. Множество королей правило на
этой земле в течение многих веков. Город гордится своими предводителями, поэтому его жители
хотят выбить имя каждого из королей на особой плите в самом центре города (дабы заполнить хоть
чем-то пустующий и безлюдный город).
У каждого короля Иннолэнда помимо имени имеется порядковый номер. Этот номер записан в
римской системе счисления рядом с именем каждого короля великого города-государства.
Например, Louis XIII был тринадцатым королем Иннолэнда, имеющим имя Louis (ох уж эти иннолэндовцы и их имена...).
Однако не все так просто устроено в этом городе. Жители Иннолэнда любят соблюдать порядок
во всем, поэтому должен соблюдаться и порядок имен на плите. Важно, чтобы имена на плите были
упорядочены в лексикографическом порядке. Однако некоторые короли могли иметь одно и то же
имя, поэтому короли с одинаковым именем они должны быть отсортированы в соответствии с их
порядковыми номерами. Например, славный король Louis IX должен быть указан на плите после
доблестного короля Louis VIII.
Жители Иннолэнда пока ещё плохо ладят с упорядочиванием имен и уж тем более с компьютерами,
поэтому они обратились за помощью к Вам — Вы-то уже давно хорошо знакомы с этими
вещами. Они передали список имен всех королей, а Вы должны вернуть им тот же список,
но имена в нем должны идти уже в нужном порядке: в желаемом списке раньше записаны те короли, у
которых имя лексикографически меньше, а среди королей с одинаковым именем раньше идут те, у
которых меньше порядковый номер.

Формат входных данных
В первой строке записано число n (1<=n<=50) — количество королей.
В следующих n строках записаны имена и порядковые номера королей. В каждой строке сначала
записано имя короля, состоящее из не более чем 20 латинских букв (первая буква имени прописная,
все последующие строчные), а затем через пробел записан его порядковый номер в виде римского
числа от 1 до 50.
Формат выходных данных
В n строках должны быть записаны имена и порядковые числа королей, упорядоченные необходимым образом.

Пример 1
входные данные
2
Louis IX
Louis VIII
выходные данные
Louis VIII
Louis IX

Пример 2
входные данные
2
Louis IX
Philippe II
выходные данные
Louis IX
Philippe II

Пример 3
входные данные
2
Philippe II
Philip II
выходные данные
Philip II
Philippe II

Замечания
-Числа от 1 до 10 обозначаются с помощью римских цифр как I, II, III, IV, V, VI, VII, VIII,
IX и X соответственно;
-Числа 20, 30, 40 и 50 обозначаются как XX, XXX, XL и L соответственно;
-Остальные двузначные числа меньшие 50 в римской записи могут быть получены путем
конкатенации римской записи десятков и римской записи единиц этого числа. Например,
47 = 40 + 7 = «XL» + «VII» = «XLVII».
"""
R_A_DICT = {'I': 1, 'V': 5, 'X': 10, 'L': 50}
A_R_LIST = [['I', 'V'], ['X', 'L']]
F = [[], [[0, 1, 0]], [[0, 2, 0]], [[0, 3, 0]], [[0, 1, 1], [0, 1, 0]], [[0, 1, 1]],
         [[0, 1, 0], [0, 1, 1]], [[0, 2, 0], [0, 1, 1]], [[0, 3, 0], [0, 1, 1]], [[1, 1, 0], [0, 1, 0]]]


def get_roman_number(n: int) -> str:
    """Возвращает строку с римским числом, соответствующим переданному арабскому.

    :param n: int - арабское число от 1 до 50
    :return: str - римское число от 1 до 50
    """
    str_n_rev = str(n)[::-1]
    rank = 0
    roman_number = ''
    for num in str_n_rev:
        formula = F[int(num)]
        for el in formula:
            cur_rank = rank + el[0]
            num_rep = el[1]
            ind = el[2]
            roman_number += A_R_LIST[cur_rank][ind] * num_rep
        rank += 1
    return roman_number[::-1]


def get_arabic_number(r: str) -> int:
    """Возвращает строку с арабским числом, соответствующим переданному римскому.

    :param r: str - римское число от 1 до 50
    :return: int - арабское число от 1 до 50
    """
    arabic_number = 0
    prev_num = 51
    for symbol in r:
        cur_num = R_A_DICT[symbol]
        if cur_num == prev_num:
            arabic_number += R_A_DICT[symbol]
        else:
            if prev_num < cur_num:
                arabic_number += cur_num
                arabic_number -= 2 * prev_num
            else:
                arabic_number += cur_num
        prev_num = cur_num

    return arabic_number


def royal_sort(names, d):
    """Сортировка и печать отсортированных имен королей.

    :param names: list - список уникальных имен королей
    :param d: dict - словарь, содержащий информацию о порядковых номерах королей
    :return: nothing
    """
    names = sorted(names)
    for name in names:
        nums = d[name]
        nums = sorted(nums)
        nums = list(map(get_roman_number, nums))
        for n in nums:
            print(name, n)


def main():
    d = {}
    names = set()
    n = int(input())
    for _ in range(n):
        name, num = input().split()
        num = get_arabic_number(num)
        names.add(name)
        if name in d.keys():
            d[name].append(num)
        else:
            d[name] = [num]
    royal_sort(list(names), d)


if __name__ == "__main__":
    main()
