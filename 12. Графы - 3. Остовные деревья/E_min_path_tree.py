"""
E. –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –ø—É—Ç–µ–π

–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ —Ç–µ—Å—Ç: 6 —Å–µ–∫—É–Ω–¥
–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –ø–∞–º—è—Ç–∏ –Ω–∞ —Ç–µ—Å—Ç: 256 –º–µ–≥–∞–±–∞–π—Ç
–≤–≤–æ–¥: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤–≤–æ–¥
–≤—ã–≤–æ–¥: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤—ã–≤–æ–¥

–í–∞–º –¥–∞–Ω –≤–∑–≤–µ—à–µ–Ω–Ω—ã–π –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥—Ä–∞—Ñ, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π ùëõ –≤–µ—Ä—à–∏–Ω –∏ ùëö —Ä—ë–±–µ—Ä.
–ù–∞–π–¥–∏—Ç–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –≤–æ–∑–º–æ–∂–Ω—É—é —Å—É–º–º—É –≤–µ—Å–æ–≤ ùëõ‚àí1 —Ä–µ–±—Ä–∞, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –≤ –≥—Ä–∞—Ñ–µ,
—á—Ç–æ–±—ã –∏–∑ –≤–µ—Ä—à–∏–Ω—ã —Å –Ω–æ–º–µ—Ä–æ–º 1 –ø–æ —ç—Ç–∏–º —Ä–µ–±—Ä–∞–º –º–æ–∂–Ω–æ –±—ã–ª–æ –¥–æ–±—Ä–∞—Ç—å—Å—è –¥–æ –ª—é–±–æ–π –¥—Ä—É–≥–æ–π –≤–µ—Ä—à–∏–Ω—ã.

–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–í –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –¥–∞–Ω—ã –¥–≤–∞ —Ü–µ–ª—ã—Ö —á–∏—Å–ª–∞ ùëõ –∏ ùëö (1‚â§ùëõ‚â§1000, 0‚â§ùëö‚â§10000) ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–µ—Ä—à–∏–Ω –∏ —Ä–µ–±–µ—Ä –≤ –≥—Ä–∞—Ñ–µ.

–í —Å–ª–µ–¥—É—é—â–∏—Ö ùëö —Å—Ç—Ä–æ–∫–∞—Ö –¥–∞–Ω—ã —Ä–µ–±—Ä–∞ –≥—Ä–∞—Ñ–∞. –†–µ–±—Ä–æ –æ–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è —Ç—Ä–æ–π–∫–æ–π —á–∏—Å–µ–ª
ùëéùëñ, ùëèùëñ –∏ ùë§ùëñ (1‚â§ùëéùëñ,ùëèùëñ‚â§ùëõ; ‚àí10^9‚â§ùë§ùëñ‚â§10^9) ‚Äî –Ω–æ–º–µ—Ä –≤–µ—Ä—à–∏–Ω—ã, –∏–∑ –∫–æ—Ç–æ—Ä–æ–π –∏—Å—Ö–æ–¥–∏—Ç —Ä–µ–±—Ä–æ, –Ω–æ–º–µ—Ä –≤–µ—Ä—à–∏–Ω—ã,
–≤ –∫–æ—Ç–æ—Ä—É—é –≤—Ö–æ–¥–∏—Ç —Ä–µ–±—Ä–æ, –∏ –≤–µ—Å —Ä–µ–±—Ä–∞.

–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–ï—Å–ª–∏ –Ω–µ–ª—å–∑—è –æ—Å—Ç–∞–≤–∏—Ç—å –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ —Ä–µ–±–µ—Ä —Ç–∞–∫, —á—Ç–æ–±—ã –∏–∑ –≤–µ—Ä—à–∏–Ω—ã —Å –Ω–æ–º–µ—Ä–æ–º 1 –º–æ–∂–Ω–æ –±—ã–ª–æ –¥–æ–±—Ä–∞—Ç—å—Å—è –¥–æ –ª—é–±–æ–π –¥—Ä—É–≥–æ–π,
–≤ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–µ –≤—ã–≤–µ–¥–∏—Ç–µ ¬´NO¬ª.

–ò–Ω–∞—á–µ, –≤ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –≤—ã–≤–µ–¥–∏—Ç–µ ¬´YES¬ª, –∞ –≤–æ –≤—Ç–æ—Ä–æ–π —Å—Ç—Ä–æ–∫–µ –≤—ã–≤–µ–¥–∏—Ç–µ –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –≤–æ–∑–º–æ–∂–Ω—É—é —Å—É–º–º—É –≤–µ—Å–æ–≤ —Ä–µ–±–µ—Ä,
–∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –æ—Å—Ç–∞–≤–∏—Ç—å.

–ü—Ä–∏–º–µ—Ä—ã
–≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
2 1
2 1 10
–≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
NO
–≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
4 5
1 2 2
1 3 3
1 4 3
2 3 2
2 4 2
–≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
YES
6

–û, –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥—Ä–∞—Ñ, –≤—ã–ø—É—Å–∫–∞–π—Ç–µ –¥–≤—É—Ö –∫–∏—Ç–∞–π—Ü–µ–≤!
"""
import sys
from collections import defaultdict
from itertools import chain


ROOT = 1
INF = float('inf')
WHITE_COLOR = 0
GREY_COLOR = 1


class Edge:
    def __init__(self, a, b, w):
        self.start = a
        self.end = b
        self.weight = w


class Graph:
    def __init__(self, n):
        self.size = n
        self.edges = defaultdict(list)
        self.edges_min = [INF for _ in range(n)]
        self.path = 0
        self.colors = [WHITE_COLOR for _ in range(n)]
        self.visited = set()
        self.distances = defaultdict(int)

    def add_edge(self, a, b, w):
        self.edges[a].append(Edge(a, b, w))

    def get_back_graph(self):
        back_graph = Graph(self.size)
        for edge in chain.from_iterable(self.edges.values()):
            back_graph.add_edge(edge.end, edge.start, edge.weight)
        return back_graph

    def dfs(self, v, color, zero=False):
        self.colors[v] = color
        for edge in self.edges[v]:
            cond = True
            if zero:
                cond = (0 == edge.weight)
            if cond and WHITE_COLOR == self.colors[edge.end]:
                self.dfs(edge.end, color, zero)

    def check_by_dfs(self, zero=False):
        color = WHITE_COLOR
        for v in range(self.size):
            if WHITE_COLOR == self.colors[v]:
                color += 1
                self.dfs(v, color, zero)
        if color == 1:
            return True
        else:
            return False

    def dfs_find_dist(self, v, dist):
        self.visited.add(v)
        for edge in self.edges[v]:
            if edge.end not in self.visited and 0 == edge.weight:
                dist = self.dfs_find_dist(edge.end, dist)
        self.distances[v] = dist
        dist += 1
        return dist

    def get_sorted_vs(self):
        dist = 0
        for v in list(self.edges.keys()):
            if v not in self.visited:
                dist = self.dfs_find_dist(v, dist)
        return sorted(range(self.size), key=self.distances.__getitem__, reverse=True)

    def get_condensation_graph(self, v_root, sorted_vs):
        color = WHITE_COLOR
        for v in sorted_vs:
            if WHITE_COLOR == self.colors[v]:
                color += 1
                self.dfs(v, color, True)

        condensation_graph = Graph(color)
        v_root = self.colors[v_root] - 1
        for edge in chain.from_iterable(self.edges.values()):
            c_start = self.colors[edge.start]
            c_end = self.colors[edge.end]
            if c_start != c_end and c_start - 1 != v_root:
                condensation_graph.add_edge(c_end - 1, c_start - 1, edge.weight)

        return condensation_graph, v_root

    def find_mst(self, v_root):
        current_graph = self
        while True:
            current_graph.colors = [WHITE_COLOR for _ in range(current_graph.size)]
            for edge in chain.from_iterable(current_graph.edges.values()):
                current_graph.edges_min[edge.end] = min(edge.weight, current_graph.edges_min[edge.end])
            for v in range(current_graph.size):
                if v != v_root:
                    if current_graph.edges_min[v] == INF:
                        return INF
                    self.path += current_graph.edges_min[v]
            for edge in chain.from_iterable(current_graph.edges.values()):
                edge.weight -= current_graph.edges_min[edge.end]

            check = current_graph.check_by_dfs(zero=True)
            if check:
                return self.path

            graph_back = current_graph.get_back_graph()
            sorted_vs = current_graph.get_sorted_vs()

            current_graph, v_root = graph_back.get_condensation_graph(v_root, sorted_vs)

        return self.path


def main():
    data = sys.stdin.buffer.read().splitlines()
    n, m = map(int, data[0].split())
    if m < n - 1:
        print('NO')
    else:
        graph = Graph(n)
        for row in data[1:]:
            u, v, w = map(int, row.split())
            if u != v and v != ROOT:
                graph.add_edge(u - 1, v - 1, w)
        graph.dfs(ROOT - 1, GREY_COLOR)
        if len(set(graph.colors)) == 1:
            if graph.find_mst(ROOT - 1) != INF:
                print('YES')
                print(graph.path)
            else:
                print('NO')
        else:
            print('NO')


if __name__ == "__main__":
    main()
