"""
C. –û—Å—Ç–æ–≤–Ω–æ–µ –¥–µ—Ä–µ–≤–æ

–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ —Ç–µ—Å—Ç: 4 —Å–µ–∫—É–Ω–¥—ã
–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –ø–∞–º—è—Ç–∏ –Ω–∞ —Ç–µ—Å—Ç: 256 –º–µ–≥–∞–±–∞–π—Ç
–≤–≤–æ–¥: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤–≤–æ–¥
–≤—ã–≤–æ–¥: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤—ã–≤–æ–¥

–î–∞–Ω—ã —Ç–æ—á–∫–∏ –Ω–∞ –ø–ª–æ—Å–∫–æ—Å—Ç–∏, —è–≤–ª—è—é—â–∏–µ—Å—è –≤–µ—Ä—à–∏–Ω–∞–º–∏ –ø–æ–ª–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞.
–í–µ—Å —Ä–µ–±—Ä–∞ —Ä–∞–≤–µ–Ω —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º–∏ –∫–æ–Ω—Ü–∞–º —ç—Ç–æ–≥–æ —Ä–µ–±—Ä–∞.
–¢—Ä–µ–±—É–µ—Ç—Å—è –≤ —ç—Ç–æ–º –≥—Ä–∞—Ñ–µ –Ω–∞–π—Ç–∏ –æ—Å—Ç–æ–≤–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –≤–µ—Å–∞.

–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–ü–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ ùëõ ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–µ—Ä—à–∏–Ω –≥—Ä–∞—Ñ–∞ (1‚â§ùëõ‚â§10000).
–ö–∞–∂–¥–∞—è –∏–∑ —Å–ª–µ–¥—É—é—â–∏—Ö ùëõ —Å—Ç—Ä–æ–∫ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–≤–∞ —Ü–µ–ª—ã—Ö —á–∏—Å–ª–∞ ùë•ùëñ, ùë¶ùëñ  ‚Äî –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã ùëñ-–π –≤–µ—Ä—à–∏–Ω—ã (‚àí10000‚â§ùë•ùëñ,ùë¶ùëñ‚â§10000).
–ù–∏–∫–∞–∫–∏–µ –¥–≤–µ —Ç–æ—á–∫–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç.

–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–ü–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ–¥–Ω–æ –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ ‚Äî –≤–µ—Å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –æ—Å—Ç–æ–≤–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞.

–ü—Ä–∏–º–µ—Ä
–≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
2
0 0
1 1
–≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
1.4142135624

–í–∏–∂—É –ø–æ–ª–Ω—ã–π –≥—Ä–∞—Ñ, –ø–∏—à—É –ü—Ä–∏–º–∞
"""
import sys
from math import sqrt

INF = float('inf')


class Graph:
    def __init__(self, n, vertexes_list):
        self.size = n
        self.vertexes = vertexes_list
        self.shortest_path = [INF for _ in range(n)]
        self.shortest_path[0] = 0
        self.visited = [0 for _ in range(n)]
        self.path = 0

    @staticmethod
    def get_edge_weight(v1, v2):
        v1_x, v1_y = v1
        v2_x, v2_y = v2
        if v1 == v2:
            return INF
        return sqrt((v1_x - v2_x) ** 2 + (v1_y - v2_y) ** 2)

    def prima(self):
        for i in range(self.size):
            v_next = None
            for v in range(self.size):
                if 1 != self.visited[v] and \
                        (v_next is None or self.shortest_path[v] < self.shortest_path[v_next]):
                    v_next = v
            self.visited[v_next] = 1
            self.path += self.shortest_path[v_next]
            for v in range(self.size):
                if v != v_next and 1 != self.visited[v]:
                    w = self.get_edge_weight(self.vertexes[v], self.vertexes[v_next])
                    self.shortest_path[v] = min(self.shortest_path[v], w)


def main():
    data = sys.stdin.buffer.read().splitlines()
    n = int(data[0])
    vertexes = [None for _ in range(n)]
    for ind, row in enumerate(data[1:]):
        x, y = map(int, row.split())
        vertexes[ind] = [x, y]
    graph = Graph(n, vertexes)
    graph.prima()
    print(graph.path)


if __name__ == "__main__":
    main()
