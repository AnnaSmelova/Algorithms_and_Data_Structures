"""
C. –†–∞–∑—Ä–µ–∑

–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ —Ç–µ—Å—Ç: 2 —Å–µ–∫—É–Ω–¥—ã
–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –ø–∞–º—è—Ç–∏ –Ω–∞ —Ç–µ—Å—Ç: 1024 –º–µ–≥–∞–±–∞–π—Ç–∞
–≤–≤–æ–¥: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤–≤–æ–¥
–≤—ã–≤–æ–¥: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤—ã–≤–æ–¥

–ù–∞–π–¥–∏—Ç–µ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑—Ä–µ–∑ –º–µ–∂–¥—É –≤–µ—Ä—à–∏–Ω–∞–º–∏ 1 –∏ ùëõ –≤ –∑–∞–¥–∞–Ω–Ω–æ–º –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –≥—Ä–∞—Ñ–µ.

–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–ù–∞ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è ùëõ (2‚â§ùëõ‚â§100) ‚Äî —á–∏—Å–ª–æ –≤–µ—Ä—à–∏–Ω –≤ –≥—Ä–∞—Ñ–µ –∏ ùëö (0‚â§ùëö‚â§400) ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–±–µ—Ä.
–ù–∞ —Å–ª–µ–¥—É—é—â–∏—Ö ùëö —Å—Ç—Ä–æ–∫–∞—Ö –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –æ–ø–∏—Å–∞–Ω–∏–µ —Ä–µ–±–µ—Ä.
–†–µ–±—Ä–æ –æ–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–æ–º–µ—Ä–∞–º–∏ –≤–µ—Ä—à–∏–Ω, –∫–æ—Ç–æ—Ä—ã–µ –æ–Ω–æ —Å–æ–µ–¥–∏–Ω—è–µ—Ç,
–∏ –µ–≥–æ –ø—Ä–æ–ø—É—Å–∫–Ω–æ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å—é (–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ, –Ω–µ –ø—Ä–µ–≤–æ—Å—Ö–æ–¥—è—â–µ–µ 10000000),
–ø—Ä–∏ —ç—Ç–æ–º –Ω–∏–∫–∞–∫–∏–µ –¥–≤–µ –≤–µ—Ä—à–∏–Ω—ã –Ω–µ —Å–æ–µ–¥–∏–Ω—è—é—Ç—Å—è –±–æ–ª–µ–µ —á–µ–º –æ–¥–Ω–∏–º —Ä–µ–±—Ä–æ–º.

–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–ù–∞ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –¥–æ–ª–∂–Ω—ã —Å–æ–¥–µ—Ä–∂–∞—Ç—å—Å—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–±–µ—Ä –≤ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–º —Ä–∞–∑—Ä–µ–∑–µ
–∏ –∏—Ö —Å—É–º–º–∞—Ä–Ω–∞—è –ø—Ä–æ–ø—É—Å–∫–Ω–∞—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å.
–ù–∞ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–æ–∫–µ –≤—ã–≤–µ–¥–∏—Ç–µ –≤–æ–∑—Ä–∞—Å—Ç–∞—é—â—É—é –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –Ω–æ–º–µ—Ä–æ–≤ —Ä–µ–±–µ—Ä
(—Ä–µ–±—Ä–∞ –Ω—É–º–µ—Ä—É—é—Ç—Å—è –≤ —Ç–æ–º –ø–æ—Ä—è–¥–∫–µ, –≤ –∫–∞–∫–æ–º –æ–Ω–∏ –±—ã–ª–∏ –∑–∞–¥–∞–Ω—ã –≤–æ –≤—Ö–æ–¥–Ω–æ–º —Ñ–∞–π–ª–µ).

–ü—Ä–∏–º–µ—Ä—ã
–≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
3 3
1 2 3
1 3 5
3 2 7
–≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
2 8
1 2

–£–º–µ–µ–º –∏—Å–∫–∞—Ç—å –ø–æ—Ç–æ–∫, —É–º–µ–µ–º –∏—Å–∫–∞—Ç—å —Ä–∞–∑—Ä–µ–∑
"""
import sys
from collections import defaultdict, deque


START_VERTEX = 0
INF = float('inf')


class Edge:
    def __init__(self, a, b, c):
        self.start = a
        self.end = b
        self.capacity = c
        self.flow = 0
        self.back_edge = None

    def set_back_edge(self, back_edge):
        self.back_edge = back_edge


class Graph:
    def __init__(self, n, m):
        self.size = n
        self.edges_cnt = m
        self.edges = defaultdict(list)
        self.real_edges = []
        self.max_flow = 0
        self.start_vertex = START_VERTEX
        self.target_vertex = n - 1
        self.used = [0 for _ in range(n)]
        self.max_capacity = 0

    def add_edge(self, a, b, c):
        edge = Edge(a, b, c)
        back_edge = Edge(b, a, c)

        back_edge.set_back_edge(edge)
        edge.set_back_edge(back_edge)

        self.edges[a].append(edge)
        self.edges[b].append(back_edge)

        self.real_edges.append(edge)
        self.max_capacity = max(self.max_capacity, c)

    def bfs(self, v, delta):
        queue = deque([v])
        current_flow = INF
        while queue:
            current_v = queue.popleft()
            for edge in self.edges[current_v]:
                if not self.used[edge.end] and edge.flow < edge.capacity and delta <= edge.capacity - edge.flow:
                    self.used[edge.end] = edge
                    current_flow = min(current_flow, edge.capacity - edge.flow)
                    queue.append(edge.end)

                    if self.target_vertex == edge.end:
                        return current_flow
        return 0

    def get_deltas_array(self):
        deltas = []
        delta = 1
        deltas.append(delta)
        while 2 * delta <= self.max_capacity:
            delta *= 2
            deltas.append(delta)
        return deltas[::-1]

    def edmonds_karp(self):
        deltas = self.get_deltas_array()
        for delta in deltas:
            current_flow = 1
            while current_flow:
                self.used = [0 for _ in range(self.size)]
                current_flow = self.bfs(self.start_vertex, delta)
                if current_flow:
                    v = self.target_vertex
                    while self.start_vertex != v:
                        u = self.used[v]
                        u.flow += current_flow
                        u.back_edge.flow -= current_flow
                        v = u.start
                self.max_flow += current_flow
        return self.max_flow

    def get_min_cut(self):
        self.edmonds_karp()
        edges_sequence = []
        flow_sum = 0
        if not self.used[0]:
            self.used[0] = 1
        for i in range(self.edges_cnt):
            edge = self.real_edges[i]
            if (self.used[edge.start] and not self.used[edge.end]) \
                    or (not self.used[edge.start] and self.used[edge.end]):
                flow_sum += edge.capacity
                edges_sequence.append(str(i + 1))

        return flow_sum, edges_sequence


def main():
    data = sys.stdin.buffer.read().splitlines()
    n, m = map(int, data[0].split())
    graph = Graph(n, m)
    for row in data[1:]:
        a, b, c = map(int, row.split())
        graph.add_edge(a - 1, b - 1, c)
    flow_sum, edges_sequence = graph.get_min_cut()
    print(len(edges_sequence), flow_sum)
    print(' '.join(edges_sequence))


if __name__ == "__main__":
    main()
