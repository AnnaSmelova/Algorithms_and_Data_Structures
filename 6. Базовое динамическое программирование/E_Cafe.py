"""
E. Кафе

ограничение по времени на тест: 2 секунды
ограничение по памяти на тест: 64 мегабайта
ввод: стандартный ввод
вывод: стандартный вывод

Около Петиного университета недавно открылось новое кафе, в котором действует следующая система скидок:
при каждой покупке более чем на 100 рублей покупатель получает купон, дающий право на один бесплатный обед
(при покупке на сумму 100 рублей и меньше такой купон покупатель не получает).

Однажды Пете на глаза попался прейскурант на ближайшие n дней.
Внимательно его изучив, он решил, что будет обедать в этом кафе все n дней,
причем каждый день он будет покупать в кафе ровно один обед.
Однако стипендия у Пети небольшая, и поэтому он хочет по максимуму использовать предоставляемую систему скидок так,
чтобы его суммарные затраты были минимальны.
Требуется найти минимально возможную суммарную стоимость обедов и номера дней,
в которые Пете следует воспользоваться купонами.

Входные данные
В первой строке входного файла записано целое число n (0≤n≤100).
В каждой из последующих n строк записано одно целое число,
обозначающее стоимость обеда в рублях на соответствующий день.
Стоимость — неотрицательное целое число, не превосходящее 300.

Выходные данные
В первой строке выдайте минимальную возможную суммарную стоимость обедов.
Во второй строке выдайте два числа k1 и k2 — количество купонов, которые останутся неиспользованными у Пети
после этих n дней и количество использованных им купонов соответственно.

В последующих k2 строках выдайте в возрастающем порядке номера дней, когда Пете следует воспользоваться купонами.
Если существует несколько решений с минимальной суммарной стоимостью, то выдайте то из них,
в котором значение k1 максимально (на случай, если Петя когда-нибудь ещё решит заглянуть в это кафе).
Если таких решений несколько, выведите любое из них.

Пример 1
входные данные
5
110
40
120
110
60
выходные данные
260
0 2
3
5

Пример 2
входные данные
3
110
110
110
выходные данные
220
1 1
2
"""
'''
Что храним в ДП: dp[i][j] - минимальная сумма стоимостей обедов для j-того дня при наличии i неиспользованных купонов.

База: Если в первый день стоимость больше 100, то купон останется => dp[1][0] = цена первого обеда.
Иначе купона не останется => dp[0][0] = цена первого обеда.

Переход: Для каждого dp[i][j] считаем возможности на следующий день: потратить купон, сохранить купон или заработать
его. Затем обновляем соотвтетствующие ячейки следующего дня dp: dp[i - 1][j + 1], dp[i][j + 1] и dp[i + 1][j + 1] по
принципу минимума.

Порядок обхода: По возрастанию j и внутри по возрастанию i.

Где ответ?: Берем минимум в последнем столбце. Если есть одинаковые, то берем тот, у которого больше купонов, т.е. i.
'''
COUPON_COST = 100
INF = float('inf')


def cafe_solution(n, costs):
    while n > 0 and costs[-1] == 0:
        n -= 1
        costs = costs[:-1]

    if n == 0:
        return 0, 0, []

    dp = [[INF] * (n + 1) for _ in range(n + 1)]
    pr = [[(-1, -1)] * (n + 1) for _ in range(n + 1)]

    if costs[0] > COUPON_COST:
        dp[1][0] = costs[0]
        dp[0][1] = costs[0]
        pr[0][1] = (1, 0)
    else:
        dp[0][0] = costs[0]

    for j in range(n):
        for i in range(n):
            if j < n - 1:
                dp_val_1 = dp[i][j] + costs[j + 1]
                if costs[j + 1] > COUPON_COST and i < n - 1:
                    if dp_val_1 < dp[i + 1][j + 1]:
                        dp[i + 1][j + 1] = dp_val_1
                        pr[i + 1][j + 1] = (i, j)
                else:
                    if dp_val_1 < dp[i][j + 1]:
                        dp[i][j + 1] = dp_val_1
                        pr[i][j + 1] = (i, j)

                if i > 0:
                    dp_val_2 = dp[i][j]
                    if dp_val_2 < dp[i - 1][j + 1]:
                        dp[i - 1][j + 1] = dp_val_2
                        pr[i - 1][j + 1] = (i, j)

    min_cost_sum = INF
    coupons_left = 0
    for i in range(n, -1, -1):
        if min_cost_sum > dp[i][n - 1]:
            min_cost_sum = dp[i][n - 1]
            coupons_left = i

    coupons_lost_days = []
    j = n - 1
    i = coupons_left
    while i > -1 or j > -1:
        pr_i = i
        pr_j = j
        i, j = pr[i][j]
        if i > pr_i:
            coupons_lost_days.append(pr_j + 1)

    return min_cost_sum, coupons_left, coupons_lost_days[::-1]


def main():
    n = int(input())
    costs = []
    for _ in range(n):
        costs.append(int(input()))
    result = cafe_solution(n, costs)
    print(result[0])
    print(result[1], len(result[2]))
    for day in result[2]:
        print(day)


if __name__ == "__main__":
    main()
