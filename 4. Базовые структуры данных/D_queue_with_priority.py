"""
D. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å ‚Äì 2

–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ —Ç–µ—Å—Ç: 3 —Å–µ–∫—É–Ω–¥—ã
–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –ø–∞–º—è—Ç–∏ –Ω–∞ —Ç–µ—Å—Ç: 256 –º–µ–≥–∞–±–∞–π—Ç
–≤–≤–æ–¥: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤–≤–æ–¥
–≤—ã–≤–æ–¥: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤—ã–≤–æ–¥

–†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—É—é –æ—á–µ—Ä–µ–¥—å. –í–∞—à–∞ –æ—á–µ—Ä–µ–¥—å –¥–æ–ª–∂–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏: –¥–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç,
–∏–∑–≤–ª–µ—á—å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç, —É–º–µ–Ω—å—à–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç, –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–π –≤–æ –≤—Ä–µ–º—è –æ–¥–Ω–æ–π –∏–∑ –æ–ø–µ—Ä–∞—Ü–∏–π.

–ï—Å–ª–∏ –∫–∞–∫–æ–π-–Ω–∏–±—É–¥—å decrease-key —É–º–µ–Ω—å—à–∞–µ—Ç —É–∂–µ —É–¥–∞–ª–µ–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç, —Ç–æ –Ω–∏—á–µ–≥–æ –¥–µ–ª–∞—Ç—å –Ω–µ –Ω—É–∂–Ω–æ.

–í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω—É–º–µ—Ä—É—é—Ç—Å—è –ø–æ –ø–æ—Ä—è–¥–∫—É, –Ω–∞—á–∏–Ω–∞—è —Å 1.

–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–°–æ–¥–µ—Ä–∂–∏—Ç—Å—è –æ–ø–∏—Å–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π —Å–æ –æ—á–µ—Ä–µ–¥—å—é.
–í –æ—á–µ—Ä–µ–¥—å –ø–æ–º–µ—â–∞—é—Ç—Å—è –∏ –∏–∑–≤–ª–µ–∫–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞, –Ω–µ –ø—Ä–µ–≤—ã—à–∞—é—â–∏–µ 10^9 –ø–æ –∞–±—Å–æ–ª—é—Ç–Ω–æ–π –≤–µ–ª–∏—á–∏–Ω–µ.

–ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç—Å—è, —á—Ç–æ –¥–ª—è –ª—é–±–æ–≥–æ decrease-key x v –∏–∑ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏—è –ø–æ–¥ –Ω–æ–º–µ—Ä–æ–º ùë• —è–≤–ª—è–µ—Ç—Å—è push.

–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–í—ã–≤–µ–¥–∏—Ç–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π extract-min –∏–∑ –¥–≤—É—Ö —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª:
–∑–Ω–∞—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ –∏ –Ω–æ–º–µ—Ä –æ–ø–µ—Ä–∞—Ü–∏–∏ push, –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–º —ç—Ç–æ—Ç —ç–ª–µ–º–µ–Ω—Ç –±—ã–ª –¥–æ–±–∞–≤–ª–µ–Ω.
–ï—Å–ª–∏ –≤ –æ—á–µ—Ä–µ–¥–∏ –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –≤—ã–≤–µ–¥–∏—Ç–µ –ª—é–±–æ–π.
–ï—Å–ª–∏ –ø–µ—Ä–µ–¥ –æ—á–µ—Ä–µ–¥–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π extract-min –æ—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞, –≤—ã–≤–µ–¥–∏—Ç–µ –∑–≤–µ–∑–¥–æ—á–∫—É.

–ü—Ä–∏–º–µ—Ä
–≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
push 3
push 4
push 2
extract-min
decrease-key 2 1
extract-min
extract-min
extract-min
–≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
2 3
1 2
3 1
*

–ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∞–º–æ–ø–∏—Å–Ω—É—é –∫—É—á—É, –∫–æ—Ç–æ—Ä—É—é –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –Ω–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º —Å–∞–º–æ—Ä–∞—Å—à–∏—Ä—è—é—â–µ–º—Å—è –º–∞—Å—Å–∏–≤–µ.
–ï—Å–ª–∏ –æ—á–µ–Ω—å —Ö–æ—á–µ—Ç—Å—è, –º–æ–∂–Ω–æ –¥–∞–∂–µ –æ–±—ã—á–Ω—ã–π –º–∞—Å—Å–∏–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–±–æ —Å —Å–∞–º–æ—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º —É–∂–µ –≤—Å–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–æ–Ω—è—Ç–Ω–æ:)
"""
import sys


class EnlargingArray:
    def __init__(self):
        self.size = 0
        self.capacity = 2
        self.elements = [None] * self.capacity
        self.steps = [None] * self.capacity

    def get_size(self):
        return self.size

    def get_el_by_index(self, ind):
        if ind < 0 or ind >= self.size:
            return None, None
        return self.elements[ind], self.steps[ind]

    def update_capacity(self, upd_type='more'):
        if upd_type == 'less':
            self.capacity //= 2
        else:
            self.capacity *= 2
        new_elements = [None] * self.capacity
        new_steps = [None] * self.capacity
        for i in range(self.size):
            new_elements[i] = self.elements[i]
            new_steps[i] = self.steps[i]
        self.elements = new_elements
        self.steps = new_steps

    def add_val(self, val, step):
        if self.size + 1 > self.capacity:
            self.update_capacity('more')
        self.elements[self.size] = val
        self.steps[self.size] = step
        self.size += 1

    def pop(self):
        if self.size:
            pop_el, pop_step = self.get_el_by_index(self.size - 1)
            self.elements[self.size - 1] = None
            self.steps[self.size - 1] = None
            self.size -= 1
        else:
            return None, None

        if self.size <= self.capacity // 4 and self.capacity > 2:
            self.update_capacity('less')

        return pop_el, pop_step


class Heap(EnlargingArray):
    def __init__(self):
        super().__init__()
        self.last_step = 0

    def sift_up(self, ind):
        while ind > 0 and self.elements[ind] <= self.elements[(ind - 1) // 2]:
            self.elements[ind], self.elements[(ind - 1) // 2] = self.elements[(ind - 1) // 2], self.elements[ind]
            self.steps[ind], self.steps[(ind - 1) // 2] = self.steps[(ind - 1) // 2], self.steps[ind]
            ind = (ind - 1) // 2

    def sift_down(self, ind):
        while 2 * ind + 1 < self.size:
            curr_el = self.elements[ind]
            left_child = self.elements[2 * ind + 1]
            if 2 * ind + 2 == self.size:
                right_child = left_child + 1
            else:
                right_child = self.elements[2 * ind + 2]
            if left_child < right_child and left_child < curr_el:
                self.elements[ind], self.elements[2 * ind + 1] = self.elements[2 * ind + 1], self.elements[ind]
                self.steps[ind], self.steps[2 * ind + 1] = self.steps[2 * ind + 1], self.steps[ind]
                ind = 2 * ind + 1
            elif right_child <= left_child and right_child < curr_el:
                self.elements[ind], self.elements[2 * ind + 2] = self.elements[2 * ind + 2], self.elements[ind]
                self.steps[ind], self.steps[2 * ind + 2] = self.steps[2 * ind + 2], self.steps[ind]
                ind = 2 * ind + 2
            else:
                break

    def extract_min(self):
        self.last_step += 1
        self.elements[0], self.elements[self.size - 1] = self.elements[self.size - 1], self.elements[0]
        self.steps[0], self.steps[self.size - 1] = self.steps[self.size - 1], self.steps[0]
        extracted_el, extracted_step = super().pop()
        self.sift_down(0)
        return extracted_el, extracted_step

    def insert_val(self, val):
        self.last_step += 1
        target_ind = self.size
        super().add_val(val, self.last_step)
        self.sift_up(target_ind)

    def decrease_val(self, step, val):
        self.last_step += 1
        i = 0
        while self.steps[i] != step and i < self.size:
            i += 1
        if i != self.size and self.steps[i] == step:
            self.elements[i] = val
            self.sift_up(i)


def main():
    operation = sys.stdin.readline().split()
    heap = Heap()
    while operation:
        if operation[0] == 'push':
            val = int(operation[1])
            heap.insert_val(val)
        elif operation[0] == 'decrease-key':
            step = int(operation[1])
            val = int(operation[2])
            heap.decrease_val(step, val)
        else:
            extract_res = heap.extract_min()
            if extract_res[0] != None:
                print(f'{extract_res[0]} {extract_res[1]}')
            else:
                print('*')
        operation = sys.stdin.readline().split()


if __name__ == "__main__":
    main()
